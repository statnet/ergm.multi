% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/InitErgmTerm.multilayer.R
\name{Layer}
\alias{Layer}
\title{A multilayer network representation.}
\usage{
Layer(..., .symmetric = NULL, .bipartite = NULL, .active = NULL)
}
\arguments{
\item{...}{layer specification, in one of three formats:
\enumerate{
\item An (optionally named) list of identically-dimensioned
networks.
\item Several networks as (optionally named) arguments.
\item A single network, a character vector, and several optional
arguments. Then, the layers are values of the named edge
attributes. The optional arguments \code{.symmetric} and
\code{.bipartite} are then interpreted as described below.
}}

\item{.symmetric}{If the layer specification is via a single
network with edge attributes and the network is directed, an
optional logical vector to specify which of the layers should be
treated as undirected.}

\item{.bipartite}{If the layer specification is via a single
network with edge attributes and the network is unipartite, an
optional integer vector to specify which of the layers should be
treated as bipartite and how many \code{b1} vertices there are.}

\item{.active}{A \link[=node-attr]{nodal attribute specification}
specifying which nodes on each network \emph{may} have ties, or a list
with an element for each network. The list will be recycled up to
the number of layers.}
}
\value{
A network object with layer metadata.
}
\description{
A function for specifying the LHS of a multilayer (a.k.a. multiplex
a.k.a. multirelational a.k.a. multivariate) ERGM.
}
\note{
The resulting network will be the "least common denominator"
network: if not all layers have the same bipartedness, all layers
will appear as unipartite to the statistics, and if any are
directed, all will be. However, \link[=ergm:ergm-terms]{certain operator terms}, particularly \code{Undir()} and \code{S()}, can be
used to construct a bipartite subgraph of a unipartite graph or
change directedness.
}
\examples{

data(florentine)

# Method 1: list of networks
flo <- Layer(list(m = flomarriage, b = flobusiness))
ergm(flo ~ L(~edges, ~m)+L(~edges, ~b))

# Method 2: networks as arguments
flo <- Layer(m = flomarriage, b = flobusiness)
ergm(flo ~ L(~edges, ~m)+L(~edges, ~b))

# Method 3: edge attributes:
flo <- flomarriage | flobusiness
flo[,, names.eval="m"] <- as.matrix(flomarriage)
flo[,, names.eval="b"] <- as.matrix(flobusiness)
flo <- Layer(flo, c("m","b"))
ergm(flo ~ L(~edges, ~m)+L(~edges, ~b))

}
\seealso{
\link[=ergm-terms]{Help on model specification} for specific terms.
}
